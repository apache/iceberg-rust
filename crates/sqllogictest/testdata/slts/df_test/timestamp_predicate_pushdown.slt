# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# Test timestamp predicate pushdown behavior
#
# IMPORTANT: DataFusion uses nanosecond precision timestamps by default.
# Iceberg stores timestamps in microseconds. Converting nanoseconds to microseconds
# loses sub-microsecond precision, which can cause incorrect predicate evaluation.
#
# Example of the precision loss problem:
#   Predicate: ts >= 100 nanoseconds
#   Converted: ts >= 0 microseconds (100ns / 1000 = 0us, losing 100ns)
#   This would incorrectly match ts = 0, which fails the original predicate.
#
# Therefore, nanosecond timestamp predicates are NOT pushed down to avoid this
# precision loss. The tests below verify that nanosecond timestamps result in
# empty predicates (predicate:[]) at the IcebergTableScan level, with filtering
# happening in DataFusion's FilterExec instead.
#
# For timestamp types with precision that fits in microseconds (second, millisecond,
# microsecond), predicate pushdown works correctly and those predicates ARE pushed down.

# Create test table with timestamp column
statement ok
CREATE TABLE default.default.test_timestamp_table (id INT NOT NULL, ts TIMESTAMP)

# Insert test data with timestamps
# Note: Iceberg timestamps are stored in microseconds
# We use CAST to convert string timestamps to proper timestamp values
query I
INSERT INTO default.default.test_timestamp_table
VALUES
  (1, CAST('2023-01-01 00:00:00' AS TIMESTAMP)),
  (2, CAST('2023-01-05 12:30:00' AS TIMESTAMP)),
  (3, CAST('2023-01-10 15:45:30' AS TIMESTAMP)),
  (4, CAST('2023-01-15 09:00:00' AS TIMESTAMP)),
  (5, CAST('2023-01-20 18:20:10' AS TIMESTAMP))
----
5

# Verify timestamp equality predicate is NOT pushed down for nanosecond timestamps
# Note: DataFusion uses nanosecond precision by default. We don't push down nanosecond
# timestamps to avoid precision loss (Iceberg stores microseconds).
# Example: 100ns / 1000 = 0us, which would incorrectly match ts >= 0us
query TT
EXPLAIN SELECT * FROM default.default.test_timestamp_table WHERE ts = CAST('2023-01-05 12:30:00' AS TIMESTAMP)
----
logical_plan
01)Filter: default.default.test_timestamp_table.ts = TimestampNanosecond(1672921800000000000, None)
02)--TableScan: default.default.test_timestamp_table projection=[id, ts], partial_filters=[default.default.test_timestamp_table.ts = TimestampNanosecond(1672921800000000000, None)]
physical_plan
01)CoalesceBatchesExec: target_batch_size=8192
02)--FilterExec: ts@1 = 1672921800000000000
03)----RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
04)------CooperativeExec
05)--------IcebergTableScan projection:[id,ts] predicate:[]

# Verify timestamp equality filtering works
query I?
SELECT * FROM default.default.test_timestamp_table WHERE ts = CAST('2023-01-05 12:30:00' AS TIMESTAMP)
----
2 2023-01-05T12:30:00

# Verify timestamp greater than predicate is NOT pushed down for nanosecond timestamps
query TT
EXPLAIN SELECT * FROM default.default.test_timestamp_table WHERE ts > CAST('2023-01-10 00:00:00' AS TIMESTAMP)
----
logical_plan
01)Filter: default.default.test_timestamp_table.ts > TimestampNanosecond(1673308800000000000, None)
02)--TableScan: default.default.test_timestamp_table projection=[id, ts], partial_filters=[default.default.test_timestamp_table.ts > TimestampNanosecond(1673308800000000000, None)]
physical_plan
01)CoalesceBatchesExec: target_batch_size=8192
02)--FilterExec: ts@1 > 1673308800000000000
03)----RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
04)------CooperativeExec
05)--------IcebergTableScan projection:[id,ts] predicate:[]

# Verify timestamp greater than filtering
query I? rowsort
SELECT * FROM default.default.test_timestamp_table WHERE ts > CAST('2023-01-10 00:00:00' AS TIMESTAMP)
----
3 2023-01-10T15:45:30
4 2023-01-15T09:00:00
5 2023-01-20T18:20:10

# Test timestamp less than or equal filtering
query I? rowsort
SELECT * FROM default.default.test_timestamp_table WHERE ts <= CAST('2023-01-05 12:30:00' AS TIMESTAMP)
----
1 2023-01-01T00:00:00
2 2023-01-05T12:30:00

# Verify timestamp range predicate (AND of two comparisons) is NOT pushed down for nanosecond timestamps
query TT
EXPLAIN SELECT * FROM default.default.test_timestamp_table
WHERE ts >= CAST('2023-01-05 00:00:00' AS TIMESTAMP)
  AND ts <= CAST('2023-01-15 23:59:59' AS TIMESTAMP)
----
logical_plan
01)Filter: default.default.test_timestamp_table.ts >= TimestampNanosecond(1672876800000000000, None) AND default.default.test_timestamp_table.ts <= TimestampNanosecond(1673827199000000000, None)
02)--TableScan: default.default.test_timestamp_table projection=[id, ts], partial_filters=[default.default.test_timestamp_table.ts >= TimestampNanosecond(1672876800000000000, None), default.default.test_timestamp_table.ts <= TimestampNanosecond(1673827199000000000, None)]
physical_plan
01)CoalesceBatchesExec: target_batch_size=8192
02)--FilterExec: ts@1 >= 1672876800000000000 AND ts@1 <= 1673827199000000000
03)----RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
04)------CooperativeExec
05)--------IcebergTableScan projection:[id,ts] predicate:[]

# Test timestamp range predicate filtering
query I? rowsort
SELECT * FROM default.default.test_timestamp_table
WHERE ts >= CAST('2023-01-05 00:00:00' AS TIMESTAMP)
  AND ts <= CAST('2023-01-15 23:59:59' AS TIMESTAMP)
----
2 2023-01-05T12:30:00
3 2023-01-10T15:45:30
4 2023-01-15T09:00:00

# Test timestamp predicate combined with other predicates
query I? rowsort
SELECT * FROM default.default.test_timestamp_table
WHERE ts >= CAST('2023-01-10 00:00:00' AS TIMESTAMP) AND id < 5
----
3 2023-01-10T15:45:30
4 2023-01-15T09:00:00

# Test timestamp NOT EQUAL predicate
query I? rowsort
SELECT * FROM default.default.test_timestamp_table WHERE ts != CAST('2023-01-05 12:30:00' AS TIMESTAMP)
----
1 2023-01-01T00:00:00
3 2023-01-10T15:45:30
4 2023-01-15T09:00:00
5 2023-01-20T18:20:10

# Test timestamp less than filtering
query I? rowsort
SELECT * FROM default.default.test_timestamp_table WHERE ts < CAST('2023-01-05 00:00:00' AS TIMESTAMP)
----
1 2023-01-01T00:00:00

# ============================================================================
# NOTE ON POSITIVE TESTS FOR MICROSECOND TIMESTAMP PUSHDOWN
# ============================================================================
#
# Ideally, we would test that TimestampMicrosecond predicates ARE pushed down.
# However, DataFusion currently uses nanosecond precision timestamps by default
# for all TIMESTAMP columns, and there's no way in SQL to force microsecond precision.
#
# The code in expr_to_predicate.rs DOES support pushing down second/millisecond/microsecond
# timestamps correctly - this is verified by the unit tests:
#   - test_scalar_value_to_datum_timestamp() in expr_to_predicate.rs
#
# Those unit tests verify:
#   ScalarValue::TimestampSecond    -> Datum::timestamp_micros (converted)  ✓
#   ScalarValue::TimestampMillisecond -> Datum::timestamp_micros (converted) ✓
#   ScalarValue::TimestampMicrosecond -> Datum::timestamp_micros (direct)   ✓
#   ScalarValue::TimestampNanosecond  -> None (precision loss avoided)      ✓
#
# If/when DataFusion adds SQL syntax to specify microsecond timestamps, or if
# the default changes back to microseconds, the positive pushdown behavior
# can be tested here in sqllogictest as well.

# Clean up: Drop the nanosecond test table
statement ok
DROP TABLE default.default.test_timestamp_table
