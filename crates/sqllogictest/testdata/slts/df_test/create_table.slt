# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# =============================================================================
# Test CREATE TABLE (catalog-backed table creation)
# =============================================================================

# Test CREATE TABLE with explicit schema
statement ok
CREATE TABLE default.default.empty_table (id INT NOT NULL, name STRING)

# Verify the empty table exists and has correct schema
query IT rowsort
SELECT * FROM default.default.empty_table
----

# Insert data into the created table
query I
INSERT INTO default.default.empty_table VALUES (1, 'Alice')
----
1

# Verify the inserted data
query IT rowsort
SELECT * FROM default.default.empty_table
----
1 Alice

# Insert multiple rows
query I
INSERT INTO default.default.empty_table VALUES (2, 'Bob'), (3, 'Charlie')
----
2

# Verify all rows
query IT rowsort
SELECT * FROM default.default.empty_table
----
1 Alice
2 Bob
3 Charlie

# Test CREATE TABLE with different column types
statement ok
CREATE TABLE default.default.typed_table (id BIGINT NOT NULL, value DOUBLE, flag BOOLEAN)

# Verify the typed table exists
query IDT rowsort
SELECT * FROM default.default.typed_table
----

# Insert data with different types
query I
INSERT INTO default.default.typed_table VALUES (100, 3.14, true), (200, 2.71, false)
----
2

# Verify typed data
query IDT rowsort
SELECT * FROM default.default.typed_table
----
100 3.14 true
200 2.71 false

# Test CREATE TABLE with nullable columns
statement ok
CREATE TABLE default.default.nullable_table (id INT NOT NULL, optional_name STRING)

# Insert with NULL value
query I
INSERT INTO default.default.nullable_table VALUES (1, 'Value'), (2, NULL)
----
2

# Verify NULL handling
query IT rowsort
SELECT * FROM default.default.nullable_table
----
1 Value
2 NULL

# =============================================================================
# Test CREATE EXTERNAL TABLE (catalog-backed table loading)
# =============================================================================

# First, create a table in the catalog that we'll load via CREATE EXTERNAL TABLE
statement ok
CREATE TABLE default.default.source_table (id INT NOT NULL, data STRING)

# Insert some data into the source table
query I
INSERT INTO default.default.source_table VALUES (1, 'first'), (2, 'second')
----
2

# Verify source table data
query IT rowsort
SELECT * FROM default.default.source_table
----
1 first
2 second

# Create an external table that loads the existing catalog table
# The table name in CREATE EXTERNAL TABLE is used to look up the table in the catalog
# LOCATION is ignored when using catalog-backed factory
statement ok
CREATE EXTERNAL TABLE source_table STORED AS ICEBERG LOCATION ''

# Query the external table - should see the same data as the catalog table
query IT rowsort
SELECT * FROM source_table
----
1 first
2 second

# Insert data via the external table (catalog-backed providers support writes)
query I
INSERT INTO source_table VALUES (3, 'third')
----
1

# Verify the insert worked - query via external table
query IT rowsort
SELECT * FROM source_table
----
1 first
2 second
3 third

# Verify the insert is visible via the original catalog table path
query IT rowsort
SELECT * FROM default.default.source_table
----
1 first
2 second
3 third

# Test CREATE EXTERNAL TABLE with namespace-qualified name
statement ok
CREATE TABLE default.default.ns_table (value INT NOT NULL)

query I
INSERT INTO default.default.ns_table VALUES (100), (200)
----
2

# Create external table with bare name (uses "default" namespace)
statement ok
CREATE EXTERNAL TABLE ns_table STORED AS ICEBERG LOCATION ''

# Query via external table
query I rowsort
SELECT * FROM ns_table
----
100
200
